"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toOpenAIMessages = exports.fromOpenAICompletion = void 0;
const crayonStream_1 = require("./crayonStream");
const fromOpenAICompletion = (completion, opts) => {
    const { stream, onText, onEnd, onError, onLLMEnd } = (0, crayonStream_1.crayonStream)(opts);
    (async () => {
        try {
            for await (const chunk of completion) {
                const content = chunk.choices[0]?.delta?.content;
                content && onText(content);
            }
            onLLMEnd();
            onEnd();
        }
        catch (error) {
            if (error instanceof Error) {
                onError(error);
            }
            else {
                onError(new Error(String(error)));
            }
        }
    })();
    return stream;
};
exports.fromOpenAICompletion = fromOpenAICompletion;
// This is a utility function to convert a Crayon message to an OpenAI message.
// Use this only when you are passing the Crayon messages directly to your backend
// and not converting them.
// Note: This type is specified as any so as to not introduce a dependency on the
// Crayon frontendmessage type.
const toOpenAIMessages = (messages) => {
    const openAIMessages = [];
    for (const message of messages) {
        if (!message.message) {
            continue;
        }
        if (message.role === "user") {
            openAIMessages.push({
                role: message.role,
                content: message.message,
            });
        }
        else if (message.role === "assistant") {
            openAIMessages.push({
                role: message.role,
                content: JSON.stringify({
                    response: message.message,
                }),
            });
        }
    }
    return openAIMessages;
};
exports.toOpenAIMessages = toOpenAIMessages;
//# sourceMappingURL=openai.js.map