"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrayonDataStreamTransformer = void 0;
const best_effort_json_parser_1 = require("best-effort-json-parser");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const types_1 = require("./types");
class CrayonDataStreamTransformer {
    reset() {
        const parsed = (0, best_effort_json_parser_1.parse)(this.streamedContent);
        const lastContent = parsed?.response?.pop?.();
        if (this.hasPendingTemplateToStream && lastContent && lastContent.type !== "text") {
            const { name, templateProps } = lastContent;
            (0, tiny_invariant_1.default)(name, "name is required in ResponseTemplate");
            this.controller?.enqueue(new types_1.ResponseTemplate(name, templateProps).toSSEString());
        }
        this.hasPendingTemplateToStream = false;
        this.streamedContent = "";
    }
    constructor(opts) {
        this.streamedContent = "";
        this.controller = null;
        this.hasPendingTemplateToStream = false;
        this.hasPendingTemplateToStream = false;
        this.streamedContent = "";
        let previouslyStreamedTextContent = "";
        const transform = new TransformStream({
            transform: async (content, controller) => {
                this.controller = controller;
                try {
                    this.streamedContent += content;
                    const parsed = (0, best_effort_json_parser_1.parse)(this.streamedContent);
                    const newContent = parsed?.response?.pop?.();
                    if (newContent?.type === "text") {
                        const prevContent = parsed.response.pop();
                        const newText = newContent.text || "";
                        if (this.hasPendingTemplateToStream && prevContent && prevContent?.type !== "text") {
                            const { name, templateProps } = prevContent;
                            (0, tiny_invariant_1.default)(name, "name is required in ResponseTemplate");
                            controller.enqueue(new types_1.ResponseTemplate(name, templateProps).toSSEString());
                            this.hasPendingTemplateToStream = false;
                        }
                        const textContent = newText.substring(previouslyStreamedTextContent.length);
                        if (textContent.length > 0) {
                            controller.enqueue(new types_1.TextChunk(textContent).toSSEString());
                        }
                        previouslyStreamedTextContent = newText;
                    }
                    else {
                        this.hasPendingTemplateToStream = true;
                        previouslyStreamedTextContent = "";
                    }
                }
                catch (error) {
                    controller.error(error);
                }
            },
            flush: async (controller) => {
                this.reset();
                await opts?.onFinish(controller);
                this.controller = null;
            },
        });
        this.readable = transform.readable;
        this.writable = transform.writable;
    }
}
exports.CrayonDataStreamTransformer = CrayonDataStreamTransformer;
//# sourceMappingURL=transformer.js.map