{"version":3,"file":"index.js","sources":["../src/encode.ts"],"sourcesContent":["import type {EventSourceChunk, EventSourceMessage} from './types'\n\nconst NEWLINES_RE = /(\\r\\n|\\r|\\n)/g\n\n/**\n * Encode an EventSource message or comment\n *\n * @param chunk - The message/comment to encode\n * @returns A well-formatted string ready to be sent to a client\n * @public\n */\nexport function encode(chunk: EventSourceChunk): string {\n  return 'comment' in chunk ? encodeComment(chunk.comment) : encodeMessage(chunk)\n}\n\n/**\n * Encode the given text as a chunk of EventSource data. Note that newlines are normalized to\n * line feed characters (`\\n`) - any carriage return (`\\r`) are lost in the process.\n *\n * @param text - The text to encode. Each line starts with a `data: `-prefix.\n * @returns A well-formed data-prefixed EventSource chunk\n * @public\n */\nexport function encodeData(text: string): string {\n  const data = `${text}`.replace(NEWLINES_RE, '\\n')\n  const lines = data.split(/\\n/)\n\n  let line = ''\n  let output = ''\n\n  for (let i = 0, numLines = lines.length; i < numLines; ++i) {\n    line = lines[i]\n\n    output += `data: ${line}`\n    output += i + 1 === numLines ? '\\n\\n' : '\\n'\n  }\n\n  return output\n}\n\n/**\n * Encode a comment as a well-formed EventSource \"comment\".\n * Each line will be prefixed with a comment prefix, eg `:`.\n *\n * @param comment - The comment to encode\n * @returns A well-formed EventSource \"comment\"\n * @public\n */\nexport function encodeComment(comment: string): string {\n  return `: ${comment.replace(NEWLINES_RE, '\\n: ')}\\n\\n`\n}\n\nfunction encodeMessage(message: Partial<EventSourceMessage>): string {\n  let output = ''\n  if (message.event) {\n    output += `event: ${message.event}\\n`\n  }\n\n  if (typeof message.retry === 'number' && Number.isFinite(message.retry)) {\n    output += `retry: ${message.retry}\\n`\n  }\n\n  if (typeof message.id === 'string' || typeof message.id === 'number') {\n    output += `id: ${message.id}\\n`\n  }\n\n  if (typeof message.data === 'string') {\n    output += encodeData(message.data)\n  } else if (output) {\n    // `encodeData()` adds chunk ending itself, so we only need to add newlines here\n    // if the chunk does _not_ contain any data.\n    output += '\\n\\n'\n  }\n\n  return output\n}\n"],"names":[],"mappings":"AAEA,MAAM,cAAc;AASb,SAAS,OAAO,OAAiC;AACtD,SAAO,aAAa,QAAQ,cAAc,MAAM,OAAO,IAAI,cAAc,KAAK;AAChF;AAUO,SAAS,WAAW,MAAsB;AAE/C,QAAM,QADO,GAAG,IAAI,GAAG,QAAQ,aAAa;AAAA,CAAI,EAC7B,MAAM,IAAI;AAEzB,MAAA,OAAO,IACP,SAAS;AAEb,WAAS,IAAI,GAAG,WAAW,MAAM,QAAQ,IAAI,UAAU,EAAE;AAChD,WAAA,MAAM,CAAC,GAEd,UAAU,SAAS,IAAI,IACvB,UAAU,IAAI,MAAM,WAAW;AAAA;AAAA,IAAS;AAAA;AAGnC,SAAA;AACT;AAUO,SAAS,cAAc,SAAyB;AAC9C,SAAA,KAAK,QAAQ,QAAQ,aAAa;AAAA,GAAM,CAAC;AAAA;AAAA;AAClD;AAEA,SAAS,cAAc,SAA8C;AACnE,MAAI,SAAS;AACb,SAAI,QAAQ,UACV,UAAU,UAAU,QAAQ,KAAK;AAAA,IAG/B,OAAO,QAAQ,SAAU,YAAY,OAAO,SAAS,QAAQ,KAAK,MACpE,UAAU,UAAU,QAAQ,KAAK;AAAA,KAG/B,OAAO,QAAQ,MAAO,YAAY,OAAO,QAAQ,MAAO,cAC1D,UAAU,OAAO,QAAQ,EAAE;AAAA,IAGzB,OAAO,QAAQ,QAAS,WAC1B,UAAU,WAAW,QAAQ,IAAI,IACxB,WAGT,UAAU;AAAA;AAAA,IAGL;AACT;"}